mod args;

use std::error::Error;
use std::fmt::{self, Display, Formatter};
use std::path::PathBuf;

use anyhow::{anyhow, Result};
use clap::{Clap, IntoApp};

pub use args::Args;

#[derive(Debug)]
pub struct NoArgumentsError;

impl Display for NoArgumentsError {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(f, "{:?}", self)
    }
}

impl Error for NoArgumentsError {
    fn source(&self) -> Option<&(dyn Error + 'static)> {
        Some(self)
    }
}

/// This is where we perform our validation of the arguments.
fn validate_arguments(mut args: Args) -> Result<Args> {
    // If a positional pattern was passed _and_ patterns via flags were passed, then
    // assume that the positional pattern is a path.
    if args.pattern.is_some() && !args.patterns.is_empty() {
        args.paths.push(PathBuf::from(args.pattern.take().unwrap()));
    }

    // We don't support binary searches.
    if args.unrestricted > 2 {
        eprintln!("Binary file searching is not supported. Changing -uuu to -uu");
        args.unrestricted = 2;
    }

    // Check we have a pattern.
    if args.pattern.is_none() && args.patterns.is_empty() {
        return Err(anyhow!("No pattern was provided!"));
    }

    Ok(args)
}

/// Prints the help generated by clap.
pub fn print_help() {
    Args::into_app().print_help().unwrap();
}

// Parses arguments from the environment (argv, etc).
pub fn parse_arguments() -> Result<Args> {
    if std::env::args().skip(1).count() == 0 {
        Err(anyhow!(NoArgumentsError))
    } else {
        validate_arguments(Args::parse())
    }
}

/// Parses arguments from a list.
#[cfg(test)]
pub fn parse_arguments_from<I, T>(itr: I) -> Result<Args>
where
    I: IntoIterator<Item = T>,
    T: Into<std::ffi::OsString> + Clone,
{
    validate_arguments(Args::parse_from(itr))
}

#[cfg(test)]
mod tests {
    use std::path::PathBuf;

    use pretty_assertions::assert_eq;

    use crate::cli::parse_arguments_from;

    #[test]
    fn checks_if_no_pattern_was_passed() {
        let args = parse_arguments_from(&["rgr", "-E", "utf8", "-A1", "-B", "10"]);
        assert!(args.is_err());
        assert_eq!(
            format!("{}", args.unwrap_err()),
            String::from("No pattern was provided!")
        );
    }

    #[test]
    fn reads_pattern_as_path_if_pattern_flag_given() {
        let args = parse_arguments_from(&["rgr", "-e", "pattern-flag", "pattern-pos", "path-pos"])
            .unwrap();

        assert_eq!(args.pattern, None);
        assert_eq!(args.patterns, vec!["pattern-flag".to_owned()]);
        assert_eq!(
            args.paths,
            vec![PathBuf::from("path-pos"), PathBuf::from("pattern-pos")]
        )
    }

    #[test]
    fn does_not_allow_unrestricted_above_two() {
        let args = parse_arguments_from(&["rgr", "-uuu", "pattern-pos"]).unwrap();
        assert_eq!(args.unrestricted, 2);
    }

    #[test]
    fn returns_rg_patterns() {
        let args = parse_arguments_from(&[
            "rgr",
            "-e",
            "pattern-flag",
            "--regexp",
            "pattern-flag-long",
            "path-pos",
        ])
        .unwrap();

        assert_eq!(
            args.rg_patterns(),
            vec!["pattern-flag", "pattern-flag-long"]
        );
    }
}
